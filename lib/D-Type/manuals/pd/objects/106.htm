
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

<head>
<title>D-Type Manual</title>
<link rel="stylesheet" type="text/css" href="../../common/include/style_001.css" />
</head>

<body>
<a href="../../common/manual/index.htm"><img src="../../common/images/index.gif" border="0" alt="Index" /></a><br />

<h1>PowerDoc Objects</h1>

<h2>Rich Text Area</h2>
<h3 id="overview">Overview</h3>
This objects represents a rich text area. In Power Engine API, a rich text area is an array of text fragments formatted according to the specified parameters and drawn within bounds of an invisible rectangular area. Functionally, the Rich Text Area object is similar to the <a href="103.htm">Text Area</a> object but is more complex. This is because a typical rich text area usually consists of many text fragments, while each fragment is formatted using a different set of typographic and layout attributes.<br />
<br />
<strong>Designated Rendering Function:</strong> pdDrawRichTextArea (10)<br />
<h3 id="links">Links</h3>
<div class="pdoc_obj_descr"><h4 id="pdTextFragmentPtr"><em><span class="field">pdTextFragmentPtr</span> (1038)</em></h4>
<p class="also_appears_in"><small>Also appears in: <a href="007.htm#pdTextFragmentPtr">Text Fragment</a>, <a href="104.htm#pdTextFragmentPtr">Rich Text Line</a>, <a href="105.htm#pdTextFragmentPtr">Rich Text Arc</a>, <a href="128.htm#pdTextFragmentPtr">Rich Text Design</a>, <a href="131.htm#pdTextFragmentPtr">Rich Text Path</a>, <a href="308.htm#pdTextFragmentPtr">Rich Text Box</a>, <a href="309.htm#pdTextFragmentPtr">Rich Button</a>, <a href="310.htm#pdTextFragmentPtr">Rich List Box</a></small></p>
<p>
Link to the <a href="007.htm">Text Fragment</a> object.<br />
<br />
This link in used to establish a link to the next text fragment. This can be the first text fragment or the fragment that follows the current one.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdBaselinePtr"><em><span class="field">pdBaselinePtr</span> (1113)</em></h4>
<p class="also_appears_in"><small>Also appears in: <a href="022.htm#pdBaselinePtr">Text Extras</a>, <a href="101.htm#pdBaselinePtr">Text Line</a>, <a href="102.htm#pdBaselinePtr">Text Arc</a>, <a href="103.htm#pdBaselinePtr">Text Area</a>, <a href="104.htm#pdBaselinePtr">Rich Text Line</a>, <a href="105.htm#pdBaselinePtr">Rich Text Arc</a>, <a href="130.htm#pdBaselinePtr">Text Path</a>, <a href="131.htm#pdBaselinePtr">Rich Text Path</a></small></p>
<p>
Link to the <a href="020.htm">Baseline</a> object.<br />
<br />
This link supplies parameters necessary to render the baselines of text rows.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="txRichTextFirstPtr"><em><span class="field">txRichTextFirstPtr</span> (2000)</em></h4>
<p>
Link to the <a href="106.htm">Rich Text Area</a> object.<br />
<br />
This link in used to establish a link to the first rich text area in a text flow chain. This link will be described more thoroughly in the future.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="txRichTextNextPtr"><em><span class="field">txRichTextNextPtr</span> (2001)</em></h4>
<p>
Link to the <a href="106.htm">Rich Text Area</a> object.<br />
<br />
This link in used to establish a link to the next rich text area in a text flow chain. This link will be described more thoroughly in the future.<br />
</p>
</div>
<h3 id="props">Properties</h3>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaDw"><em><span class="field">pdTextAreaDw</span> (1025)</em> &nbsp; <small class="label">PD_LONG_SIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaDw">Text Area</a></small></p>
<p>
Width of a text area in document units. Must not be negative. The value 0 is special and means an infinite width; in this configuration the text never wraps and just outputs on one infinitely long text line (the only text line in that text area).<br />
<br />
<strong>Sample values:</strong><br />
<br />
500 = Width of 500 document units<br />
1000 = Width of 1000 document units<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaDh"><em><span class="field">pdTextAreaDh</span> (1026)</em> &nbsp; <small class="label">PD_LONG_SIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaDh">Text Area</a></small></p>
<p>
Height of a text area in document units. Must not be negative. The value 0 is special and means an infinite height; in this configuration the text never flows to any subsequent text areas and just keeps wrapping in one infinitely high text area.<br />
<br />
<strong>Sample values:</strong><br />
<br />
500 = Height of 500 document units<br />
1000 = Height of 1000 document units<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdGlobalDirection"><em><span class="field">pdGlobalDirection</span> (1075)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="101.htm#pdGlobalDirection">Text Line</a>, <a href="102.htm#pdGlobalDirection">Text Arc</a>, <a href="103.htm#pdGlobalDirection">Text Area</a>, <a href="104.htm#pdGlobalDirection">Rich Text Line</a>, <a href="105.htm#pdGlobalDirection">Rich Text Arc</a>, <a href="130.htm#pdGlobalDirection">Text Path</a>, <a href="131.htm#pdGlobalDirection">Rich Text Path</a></small></p>
<p>
Global text direction and bidirectional text display method.<br />
<br />
<strong>Supported values:</strong><br />
<br />
A) Horizontal Layout (Text in Rows) and Bidirectional Reordering:<br />
<br />
0 = Left-to-Right, Top-to-Bottom (e.g. Latin, Cyrillic, Greek)<br />
1 = Right-to-Left, Top-to-Bottom (e.g. Arabic, Hebrew)<br />
2 = Left-to-Right, Bottom-to-Top<br />
3 = Right-to-Left, Bottom-to-Top<br />
4 = Same as 0 but swap Portrait &amp; Landscape<br />
5 = Same as 1 but swap Portrait &amp; Landscape<br />
6 = Same as 2 but swap Portrait &amp; Landscape<br />
7 = Same as 3 but swap Portrait &amp; Landscape<br />
<br />
B) Vertical Layout (Text in Columns) and Bidirectional Reordering:<br />
<br />
8 = Top-to-Bottom, Right-to-Left (e.g. Vertical Chinese)<br />
9 = Bottom-to-Top, Right-to-Left<br />
10 = Top-to-Bottom, Left-to-Right<br />
11 = Bottom-to-Top, Left-to-Right<br />
12 = Same as 8 but swap Portrait &amp; Landscape<br />
13 = Same as 9 but swap Portrait &amp; Landscape<br />
14 = Same as 10 but swap Portrait &amp; Landscape<br />
15 = Same as 11 but swap Portrait &amp; Landscape<br />
<br />
C) Horizontal Layout (Text in Rows) and Bidirectional Rotation:<br />
<br />
16 = Left-to-Right, Top-to-Bottom (e.g. Latin, Cyrillic, Greek)<br />
17 = Right-to-Left, Top-to-Bottom (e.g. Arabic, Hebrew)<br />
18 = Left-to-Right, Bottom-to-Top<br />
19 = Right-to-Left, Bottom-to-Top<br />
20 = Same as 16 but swap Portrait &amp; Landscape<br />
21 = Same as 17 but swap Portrait &amp; Landscape<br />
22 = Same as 18 but swap Portrait &amp; Landscape<br />
23 = Same as 19 but swap Portrait &amp; Landscape<br />
<br />
D) Vertical Layout (Text in Columns) and Bidirectional Rotation:<br />
<br />
24 = Top-to-Bottom, Right-to-Left (e.g. Vertical Chinese)<br />
25 = Bottom-to-Top, Right-to-Left<br />
26 = Top-to-Bottom, Left-to-Right<br />
27 = Bottom-to-Top, Left-to-Right<br />
28 = Same as 24 but swap Portrait &amp; Landscape<br />
29 = Same as 25 but swap Portrait &amp; Landscape<br />
30 = Same as 26 but swap Portrait &amp; Landscape<br />
31 = Same as 27 but swap Portrait &amp; Landscape<br />
<br />
<strong>Notes:</strong><br />
<br />
D-Type Engine can display text in horizontal writing mode (text in rows) and vertical writing mode (text in columns). In horizontal writing mode, the global text progression can be Letf-to-Right/Top-to-Bottom, Right-to-Left/Top-to-Bottom, Letf-to-Right/Bottom-to-Top or Right-to-Left/Bottom-to-Top. In vertical writing mode, the global text progression can be Top-to-Bottom/Right-to-Left, Bottom-to-Top/Right-to-Left, Top-to-Bottom/Left-to-Right or Bottom-to-Top/Left-to-Right.<br />
<br />
Additionally, D-Type Engine can display bidirectional text (e.g. a mixture of left-to-right text such as English or Chinese and right-to-left text such as Arabic or Hebrew) using two different methods: the first method is Bidirectional Reordering, the second method is Bidirectional Rotation. Visually, these two methods produce quite different output. However, both are suitable for displaying text that was processed by the Unicode Bidirectional Algorithm (BiDi).<br />
<br />
With Bidirectional Reordering the characters are reordered for display depending on the relative direction of the containing text fragment. Thus, a left-to-right text fragment has its characters ordered (visually) in the opposite order from a right-to-left text fragment. While reading bidirectional text, from start to end, the reader must alternate the reading direction (left-to-right/right-to-left in horizontal writing mode or top-to-bottom/bottom-to-top in vertical writing mode) each time a change of direction occurs. This is also the progression of the cursor as it advances from one character to another. This means that with Bidirectional Reordering, the order in which the characters are displayed is not the same as the order in which they are stored in memory (logical or storage order).<br />
<br />
With Bidirectional Rotation all characters are ordered uniformly (e.g. from left-to-right in horizontal writing mode or top-to-bottom in vertical writing mode) regardless of whether the containing text fragment has a left-to-right or right-to-left direction. However, their rotation depends on the relative direction of the containing text fragment. More specifically, characters that are part of a left-to-right text fragment are rotated 180 degrees relative to the characters that are part of a right-to-left text fragment. Thus, while reading bidirectional text, from start to end, the reader must rotate the display surface or tilt his/her head (clockwise or counterclockwise) each time a change of direction occurs. However, the reading direction and the progression of the cursor remain uniform. This also means that with Bidirectional Rotation, the order in which the characters are displayed is the same as the order in which they are stored in memory.<br />
<br />
Bidirectional Reordering is frequently used in horizontal writing mode and also works well in vertical writing mode. Bidirectional Rotation is typically not used in horizontal writing mode due to the fact that almost all Unicode scripts, when displayed in horizontal writing mode, have their orientation set to portrait (meaning that the glyph's x-axis in font design space is parallel with the baseline). Using Bidirectional Rotation in this case would require the user to rotate the display surface by 180 degrees (clockwise or counterclockwise) each time a change of direction is encountered -- which is, needles to say, far from practical. However, Bidirectional Rotation works well in vertical writing mode. This is due to the fact that vertical writing is used mostly with CJK scripts (Chinese/Japanese/Korean) which typically have their orientation set to landscape (meaning that the glyph's x-axis in font design space is perpendicular to the baseline). Non-CJK scripts, such as Latin or Arabic then have their orientation set to portrait. Under this scheme, the reading direction and the progression of the cursor is always top-to-bottom. When reading the majority of content (i.e. CJK text), there is no need to rotate the display surface. However, when a left-to-right text fragment (e.g. English) is encountered, the reader rotates the display surface by 90 degrees clockwise. Similarly, when a right-to-left text fragment (e.g. Arabic) is encountered, the reader rotates the display surface by 90 degrees counterclockwise. In all three cases (Chinese, English and Arabic) the characters are ordered from top to bottom and the reader is never expected to alter the reading direction (which would otherwise be required if Bidirectional Reordering was used). This is not to say that Bidirectional Reordering cannot be used in vertical writing mode. However, Bidirectional Rotation might work better in certain applications as rotating the display surface by 90 degrees clockwise or counterclockwise relative to the vertical baseline is sometimes considered a more practical way of reading vertical bidirectional text.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="txLockStatus"><em><span class="field">txLockStatus</span> (2005)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="101.htm#txLockStatus">Text Line</a>, <a href="102.htm#txLockStatus">Text Arc</a>, <a href="103.htm#txLockStatus">Text Area</a>, <a href="104.htm#txLockStatus">Rich Text Line</a>, <a href="105.htm#txLockStatus">Rich Text Arc</a>, <a href="130.htm#txLockStatus">Text Path</a>, <a href="131.htm#txLockStatus">Rich Text Path</a></small></p>
<p>
A flag that indicates whether and how the text is locked for user interactions.<br />
<br />
<strong>Supported values:</strong><br />
<br />
0 = Text is not locked (all user interactions are enabled)<br />
<br />
1 = Text is completely locked (all user interactions are disabled)<br />
<br />
2 = Text is locked for both editing and formatting/styling (but a user can still move the cursor and make text selections)<br />
<br />
3 = Text is locked for editing but not for formatting/styling (and a user can still move the cursor and make text selections)<br />
<br />
4 = Text is locked for formatting/styling but not for editing (and a user can still move the cursor and make text selections)<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdDeviceMode"><em><span class="field">pdDeviceMode</span> (1101)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="101.htm#pdDeviceMode">Text Line</a>, <a href="103.htm#pdDeviceMode">Text Area</a>, <a href="104.htm#pdDeviceMode">Rich Text Line</a></small></p>
<p>
Indicates whether text should be rendered in a device independent, device dependent or mixed mode. Review the "Rendering Great Looking Text With D-Type" document for a comprehensive overview.<br />
<br />
<strong>Supported values:</strong><br />
<br />
0 = Device Independent Mode. Text will be rendered in a device independent mode, which means that text metrics are independent of the device, resolution or zoom factor and are mathematically accurate. Therefore, in text areas and rich text areas, characters that are supposed to vertically line up will always line up. In addition, all text lines will always fit within the width of the enclosing area. This is the default mode. Recommended for WYSIWYG applications.<br />
<br />
1 = Device Dependent Mode #1. Text will be rendered in a device dependent mode, which means that text metrics are device specific. This mode utilizes a complex device dependent formula that is specially crafted to give good looking character spacing (calculated in whole-pixel units). This mode corresponds to the DV_TEXTMODE_DEVICE value in D-Type Standard Engine. See the dtxTextDoOutput family of functions in D-Type Standard Engine Manual for details.<br />
<br />
Important note for text areas and rich text areas: Because this mode is device dependent, please be aware that the length of certain text lines will sometimes exceed the width of the enclosing area; also characters that are supposed to vertically line up will usually not line up. This behaviour is by design.<br />
<br />
2 = Device Dependent Mode #2. Text will be rendered in a device dependent mode, which means that text metrics are device specific. This mode is similar to Device Dependent Mode #1 since it also utilizes a complex device dependent formula crafted to give good looking character spacing. However, this mode produces even better looking and easier to read text, especially at smaller sizes. This is accomplished by artificially increasing the amount of character spacing between certain characters and in certain conditions. This mode corresponds to the DV_TEXTMODE_DEVICE_2 value in D-Type Standard Engine. See the dtxTextDoOutput family of functions in D-Type Standard Engine Manual for details.<br />
<br />
Important note for text areas and rich text areas: Because this mode is device dependent (and also because the character spacing may be artificially increased), please be aware that the length of certain text lines will sometimes exceed the width of the enclosing area; also characters that are supposed to vertically line up will usually not line up. This behaviour is by design.<br />
<br />
101 = Mixed Mode #1. By default, the engine will render all text using Device Dependent Mode #1. In text areas and rich text areas, however, if there are any text lines whose length would exceed the width of the enclosing area, then those text lines will be rendered in a device independent manner. Consequently, for text areas and rich text areas, this mode guarantees that all text lines will always fit within the width of the enclosing area.<br />
<br />
102 = Mixed Mode #2. By default, the engine will render all text using Device Dependent Mode #2. In text areas and rich text areas, however, if there are any text lines whose length would exceed the width of the enclosing area, then the engine will attempt to render those lines using Device Dependent Mode #1. If, after this, there are still some text lines whose length exceeds the width of the enclosing area, then those lines will be rendered in a device independent manner. Consequently, for text areas and rich text areas, this mode guarantees that all text lines will always fit within the width of the enclosing area. This mode usually produces great looking character spacing and is highly recommended whenever true WYSIWYG support is not a priority.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdGlyphStart"><em><span class="field">pdGlyphStart</span> (1076)</em> &nbsp; <small class="label">PD_ARR_LONG_SIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="101.htm#pdGlyphStart">Text Line</a>, <a href="102.htm#pdGlyphStart">Text Arc</a>, <a href="103.htm#pdGlyphStart">Text Area</a>, <a href="104.htm#pdGlyphStart">Rich Text Line</a>, <a href="105.htm#pdGlyphStart">Rich Text Arc</a>, <a href="130.htm#pdGlyphStart">Text Path</a>, <a href="131.htm#pdGlyphStart">Rich Text Path</a></small></p>
<p>
Start glyph position within the first text fragment, i.e. the index of the glyph in the first text fragment from which the text layout and display starts. This value cannot be negative and must be less than the length of the first text fragment.<br />
<br />
This property is useful when building text flows (i.e. when text fragments span more than one text area). In most other cases, this property should be omitted or its value should be set to 0.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaType"><em><span class="field">pdTextAreaType</span> (1073)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaType">Text Area</a></small></p>
<p>
Type of text area and control of empty text lines.<br />
<br />
The first 6 bits (Bit 0 - Bit 5) are interpreted as a single 6 bit value. This value specifies the type of the text area and can be one of the following:<br />
<br />
<strong>Supported values:</strong><br />
<br />
0 = Rectangular<br />
<br />
5 = Custom (use in conjunction with pdTextAreaEdgeLeft and/or pdTextAreaEdgeRight)<br />
6 = Custom With Extra Precision (use in conjunction with pdTextAreaEdgeLeft and/or pdTextAreaEdgeRight)<br />
<br />
10 = Quarter-Circular A<br />
11 = Quarter-Circular B<br />
12 = Quarter-Circular C<br />
13 = Quarter-Circular D<br />
14 = Half-Circular A<br />
15 = Half-Circular B<br />
16 = Half-Circular C<br />
17 = Half-Circular D<br />
18 = Circular<br />
<br />
20 = Quarter-Diamond A<br />
21 = Quarter-Diamond B<br />
22 = Quarter-Diamond C<br />
23 = Quarter-Diamond D<br />
24 = Half-Diamond A<br />
25 = Half-Diamond B<br />
26 = Half-Diamond C<br />
27 = Half-Diamond D<br />
28 = Diamond<br />
<br />
The seventh bit (Bit 6) is interpreted as a single bit value that specifies how the left (pdTextAreaEdgeLeft) and right edge (pdTextAreaEdgeRight) in non-rectangular text areas will be calculated. If this bit is set (1), the calculation will be more precise but slower; otherwise, if this bit is unset (0), the calculation will be less precise but faster. In rectangular text areas, this bit is ignored.<br />
<br />
The final bit (Bit 7) is interpreted as a single bit value that signifies whether the control of empty text lines is enabled. If this bit is set (1), the control of empty text lines is enabled; otherwise, if this bit is unset (0), the control of empty text lines is disabled.<br />
<br />
When the control of empty text lines is enabled, D-Type Engine will ignore any trailing empty text lines (i.e. text lines that only contain white characters such as spaces or carriage returns) when performing vertical alignment of text in this text area. This is useful in high-end text layout applications that require more professional vertical alignment of text.<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaEdgeLeft"><em><span class="field">pdTextAreaEdgeLeft</span> (1077)</em> &nbsp; <small class="label">PD_ARR_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaEdgeLeft">Text Area</a></small></p>
<p>
Left edge polyline for text areas. This property makes it possible to create text areas with a custom (i.e. user-defined) left edge. In order for the custom left edge to take effect, the pdTextAreaType property must be set to 5 or 6.<br />
<br />
The left edge polyline is defined as a sequence of connected segments which can be made of lines, Quadratic B-Spline and/or Bezier curves. Each sequence begins with the descriptor (value 20, 25 or 24) followed by an appropriate number of coordinates for the control points as shown below:<br />
<br />
<strong>Line</strong>: 20, X1, Y1<br />
<strong>Quadratic B-Spline Curve</strong>: 25, X1, Y1, X2, Y2<br />
<strong>Bezier Curve</strong>: 24, X1, Y1, X2, Y2, X3, Y3<br />
<br />
The size of each descriptor value (20, 25 or 24) is always 1 byte.<br />
<br />
When pdTextAreaType is 5, the size of each coordinate is 1 byte. In this case X1, X2 and X3 represent X coordinates of the segment's control points and must be in the 0-255 range. The value 0 means 0% of the text area width while the value 255 means 100% of the text area width. Similarly, Y1, Y2 and Y3 represent Y coordinates of the segment's control points and must be in the 0-255 range. The value 0 means 0% of the text area height while the value 255 means 100% of the text area height.<br />
<br />
When pdTextAreaType is 6, the size of each coordinate is 2 bytes (little endian byte ordering). In this case X1, X2 and X3 represent X coordinates of the segment's control points and must be in the 0 - 65,535 range. The value 0 means 0% of the text area width while the value 65,535 means 100% of the text area width. Similarly, Y1, Y2 and Y3 represent Y coordinates of the segment's control points and must be in the 0 - 65,535 range. The value 0 means 0% of the text area height while the value 65,535 means 100% of the text area height.<br />
<br />
Implicitly, the first control point is always located at the coordinate (0, 0) which is the top left corner of the text area. Therefore, the user definition of the polyline starts with the second control point. In addition, the last control point is automatically placed at the coordinate (x_last, y_max) where x_last is the X coordinate of the last user defined control point and y_max is 255 (when pdTextAreaType is 5) or 65,535 (when pdTextAreaType is 6). In this way the polyline and the text area always have the same height.<br />
<br />
Although any sequence of connected lines, Quadratic B-Spline and/or Bezier curves can be used to define a polyline, the Y coordinates should be specified in a non-decreasing order. That is, any time a new Y coordinates is specified, its value should not be less than the value of the previously specified Y coordinate. This is to ensure that the polyline does not have multiple intersections with any horizontal line. This restriction does not apply to X coordinates.<br />
<br />
<strong>Sample values (when pdTextAreaType is 5):</strong><br />
<br />
"<strong>25</strong>, 91, 64, 26, 128, <strong>20</strong>, 102, 192"<br />
"<strong>20</strong>, 255, 0, <strong>20</strong>, 190, 90, <strong>24</strong>, 190, 200, 140, 200, 70, 210, <strong>20</strong>, 0, 255"<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaEdgeRight"><em><span class="field">pdTextAreaEdgeRight</span> (1078)</em> &nbsp; <small class="label">PD_ARR_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaEdgeRight">Text Area</a></small></p>
<p>
Right edge polyline for text areas. This property makes it possible to create text areas with a custom (i.e. user-defined) right edge. In order for the custom right edge to take effect, the pdTextAreaType property must be set to 5 or 6.<br />
<br />
The right edge polyline is defined as a sequence of connected segments which can be made of lines, Quadratic B-Spline and/or Bezier curves. Each sequence begins with the descriptor (value 20, 25 or 24) followed by an appropriate number of coordinates for the control points as shown below:<br />
<br />
<strong>Line</strong>: 20, X1, Y1<br />
<strong>Quadratic B-Spline Curve</strong>: 25, X1, Y1, X2, Y2<br />
<strong>Bezier Curve</strong>: 24, X1, Y1, X2, Y2, X3, Y3<br />
<br />
The size of each descriptor value (20, 25 or 24) is always 1 byte.<br />
<br />
When pdTextAreaType is 5, the size of each coordinate is 1 byte. In this case X1, X2 and X3 represent X coordinates of the segment's control points and must be in the 0-255 range. The value 0 means 0% of the text area width while the value 255 means 100% of the text area width. Similarly, Y1, Y2 and Y3 represent Y coordinates of the segment's control points and must be in the 0-255 range. The value 0 means 0% of the text area height while the value 255 means 100% of the text area height.<br />
<br />
When pdTextAreaType is 6, the size of each coordinate is 2 bytes (little endian byte ordering). In this case X1, X2 and X3 represent X coordinates of the segment's control points and must be in the 0 - 65,535 range. The value 0 means 0% of the text area width while the value 65,535 means 100% of the text area width. Similarly, Y1, Y2 and Y3 represent Y coordinates of the segment's control points and must be in the 0 - 65,535 range. The value 0 means 0% of the text area height while the value 65,535 means 100% of the text area height.<br />
<br />
Implicitly, the first control point is always located at the coordinate (0, 0) which is the top right corner of the text area. Therefore, the user definition of the polyline starts with the second control point. In addition, the last control point is automatically placed at the coordinate (x_last, y_max) where x_last is the X coordinate of the last user defined control point and y_max is 255 (when pdTextAreaType is 5) or 65,535 (when pdTextAreaType is 6). In this way the polyline and the text area always have the same height.<br />
<br />
Although any sequence of connected lines, Quadratic B-Spline and/or Bezier curves can be used to define a polyline, the Y coordinates should be specified in a non-decreasing order. That is, any time a new Y coordinates is specified, its value should not be less than the value of the previously specified Y coordinate. This is to ensure that the polyline does not have multiple intersections with any horizontal line. This restriction does not apply to X coordinates.<br />
<br />
<strong>Sample values (when pdTextAreaType is 5):</strong><br />
<br />
"<strong>20</strong>, 70, 45, <strong>24</strong>, 140, 55, 190, 55, 190, 165, <strong>20</strong>, 255, 255"<br />
"<strong>20</strong>, 51, 64, <strong>20</strong>, 26, 128, <strong>20</strong>, 102, 192"<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaRowType"><em><span class="field">pdTextAreaRowType</span> (1065)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaRowType">Text Area</a></small></p>
<p>
Row spacing calculation method.<br />
<br />
0 = Mathematically calculate spacing between text rows.<br />
<br />
10 = Respect typographic values when calculating spacing between text rows. The typographic values must be defined in the font file in order for this method to function as intended. For text in horizontal layout (rows), the typographic values are supplied by the sTypoAscender and sTypoDescender fields of the OS/2 table (TrueType/OpenType fonts) or the Ascender and Descender key of the Font Metrics (AFM) file (Type 1/Type 3 fonts). D-Type Font Engine refers to these values in a portable fashion via the DV_NVAL_ASCENDER and DV_NVAL_DESCENDER identifiers. For text in vertical layout (columns), the typographic values are supplied by the vertTypoAscender and vertTypoDescender fields of the vhea table (TrueType/OpenType fonts). D-Type Font Engine refers to these values in a portable fashion via the DV_NVAL_VER_ASCENDER and DV_NVAL_VER_DESCENDER identifiers. If the typographic values are not defined in the font file, method 0 will be used instead.<br />
<br />
20 = Same as method 10 but adds an additional linegap, if available in the font. For text in horizontal layout (rows), this additional linegap is supplied by the sTypoLineGap field of the OS/2 table (TrueType/OpenType fonts); in Type 1 and Type 3 fonts, this information is most likely not available. D-Type Font Engine refers to this value in a portable fashion via the DV_NVAL_LINEGAP identifier. For text in vertical layout (columns), the additional linegap is supplied by the vertTypoLineGap field of the vhea table (TrueType/OpenType fonts). D-Type Font Engine refers to this value in a portable fashion via the DV_NVAL_VER_LINEGAP identifier.<br />
<br />
30 = Respect Windows specific typographic values when calculating spacing between text rows. The Windows specific typographic values must be defined in the font file in order for this method to function as intended. For text in either horizontal layout (rows) or vertical layout (columns), the Windows specific typographic values are supplied by the usWinAscent and usWinDescent fields of the OS/2 table (TrueType/OpenType fonts). D-Type Font Engine refers to these values in a portable fashion via the DV_NVAL_WIN_ASCENT and DV_NVAL_WIN_DESCENT identifiers. If the Windows specific typographic values are not defined in the font file, method 0 will be used instead.<br />
<br />
110 = Same as method 10, but horizontal typographic values are used for text in vertical layout (columns). Although not ideal from a purely mathematical standpoint, this method seems to work well with most CJK fonts.<br />
<br />
120 = Same as method 20, but horizontal typographic values are used for text in vertical layout (columns). Although not ideal from a purely mathematical standpoint, this method seems to work well with most CJK fonts.<br />
<br />
Other property values will be described in the future.<br />
<br />
<strong>Supported values:</strong> 0, 1, 2, 3, 4, 10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 30, 31, 32, 33, 34, 110, 111, 112, 113, 114, 120, 121, 122, 123, 124<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdWrapType"><em><span class="field">pdWrapType</span> (1066)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdWrapType">Text Area</a>, <a href="130.htm#pdWrapType">Text Path</a>, <a href="131.htm#pdWrapType">Rich Text Path</a></small></p>
<p>
Text wrap method.<br />
<br />
<strong>Supported values:</strong><br />
<br />
0 = Soft Wrap Enabled<br />
1 = Soft Wrap Disabled - trim text after any character<br />
2 = Soft Wrap Disabled - trim text only after space or some other breakable character (e.g. CJK) but not after a hyphen<br />
3 = Soft Wrap Disabled - trim text only after space or some other breakable character (e.g. CJK) or after a hyphen<br />
4 = Soft Wrap Disabled - trim text after any character and add a horizontal ellipsis<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaVAlign"><em><span class="field">pdTextAreaVAlign</span> (1109)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaVAlign">Text Area</a></small></p>
<p>
Vertical alignment of text inside a text area, when the text flow does not end or break in that text area.<br />
<br />
<strong>Supported values:</strong><br />
<br />
0 = Top<br />
1 = Middle<br />
2 = Bottom<br />
3 = Justified<br />
</p>
</div>
<div class="pdoc_obj_descr"><h4 id="pdTextAreaVAlignEnd"><em><span class="field">pdTextAreaVAlignEnd</span> (1110)</em> &nbsp; <small class="label">PD_BYTE_UNSIGNED</small></h4>
<p class="also_appears_in"><small>Also appears in: <a href="103.htm#pdTextAreaVAlignEnd">Text Area</a></small></p>
<p>
Vertical alignment of text inside a text area, when the text flow ends or breaks in that text area.<br />
<br />
<strong>Supported values:</strong><br />
<br />
0 = Top<br />
1 = Middle<br />
2 = Bottom<br />
3 = Justified<br />
</p>
</div>
<h3 id="example">Example</h3>
<p><strong>C/C++</strong></p>
<div class="box_field"><tt>DT_ID_SLONG obj[10];<br />
<br />
obj[0] = pdObjAdd(pd, 0, "Text Fragment Outline Style");<br />
obj[1] = pdObjAdd(pd, 0, "Text Fragment Body Style");<br />
obj[2] = pdObjAdd(pd, 0, "Text Fragment Shadow Style");<br />
obj[3] = pdObjAdd(pd, 0, "Text Fragment Outline");<br />
obj[4] = pdObjAdd(pd, 0, "Text Fragment Shadow");<br />
obj[5] = pdObjAdd(pd, 0, "Text Fragment Typography");<br />
obj[6] = pdObjAdd(pd, 0, "Text Fragment Layout");<br />
obj[7] = pdObjAdd(pd, 0, "Text Fragment Ruler");<br />
obj[8] = pdObjAdd(pd, 0, "Text Fragment");<br />
<strong>obj[9] = pdObjAdd(pd, 0, "RichTextArea");</strong><br />
<br />
<span class="codecomment">/* Properties for object 0 */</span><br />
pdPropAdd(pd, obj[0], pdRGBT, "50641400", PD_HEX);<br />
<br />
<span class="codecomment">/* Properties for object 1 */</span><br />
pdPropAdd(pd, obj[1], pdRGBT, "B4961400", PD_HEX);<br />
<br />
<span class="codecomment">/* Properties for object 2 */</span><br />
pdPropAdd(pd, obj[2], pdRGBT, "80808078", PD_HEX);<br />
pdPropAdd(pd, obj[2], pdEP, "030A", PD_HEX);<br />
<br />
<span class="codecomment">/* Properties for object 3 */</span><br />
pdLinkAdd(pd, obj[3], pdStylePtr, obj[0]);<br />
pdPropAdd(pd, obj[3], pdLineThickness, "240", PD_WORD_SIGNED);<br />
<br />
<span class="codecomment">/* Properties for object 4 */</span><br />
pdLinkAdd(pd, obj[4], pdStylePtr, obj[2]);<br />
pdPropAdd(pd, obj[4], pdShadowDx, "5", PD_WORD_SIGNED);<br />
pdPropAdd(pd, obj[4], pdShadowDy, "5", PD_WORD_SIGNED);<br />
<br />
<span class="codecomment">/* Properties for object 5 */</span><br />
pdLinkAdd(pd, obj[5], pdBodyPtr, obj[1]);<br />
pdLinkAdd(pd, obj[5], pdShadowPtr, obj[4]);<br />
pdLinkAdd(pd, obj[5], pdOutlinePtr, obj[3]);<br />
pdPropAdd(pd, obj[5], pdFontIndex, "0", PD_WORD_SIGNED);<br />
pdPropAdd(pd, obj[5], pdFontDw, "90", PD_WORD_SIGNED);<br />
pdPropAdd(pd, obj[5], pdFontDh, "90", PD_WORD_SIGNED);<br />
<br />
<span class="codecomment">/* Properties for object 6 */</span><br />
pdPropAdd(pd, obj[6], pdSpacingRow, "10", PD_WORD_SIGNED);<br />
pdPropAdd(pd, obj[6], pdSpacingLetter, "5", PD_WORD_SIGNED);<br />
pdPropAdd(pd, obj[6], pdKerning, "1", PD_BYTE_UNSIGNED);<br />
pdPropAdd(pd, obj[6], pdAlign, "3", PD_BYTE_UNSIGNED);<br />
<br />
<span class="codecomment">/* Properties for object 7 */</span><br />
pdPropAdd(pd, obj[7], pdTabStopPositions, "40, 80, 150, 220", PD_ARR_BYTE_UNSIGNED);<br />
pdPropAdd(pd, obj[7], pdTabStopFlags, "1, 0, 0, 2", PD_ARR_BYTE_UNSIGNED);<br />
<br />
<span class="codecomment">/* Properties for object 8 */</span><br />
pdLinkAdd(pd, obj[8], pdTypographyPtr, obj[5]);<br />
pdLinkAdd(pd, obj[8], pdTextLayoutPtr, obj[6]);<br />
pdLinkAdd(pd, obj[8], pdTextRulerHorPtr, obj[7]);<br />
pdPropAdd(pd, obj[8], pdTextString_08, "This is a simple text fragment", PD_ASC);<br />
<br />
<span class="codecomment">/* Properties for object 9 */</span><br />
<strong>pdLinkAdd(pd, obj[9], pdTextFragmentPtr, obj[8]);<br />
pdPropAdd(pd, obj[9], pdTextAreaDw, "800", PD_LONG_SIGNED);<br />
pdPropAdd(pd, obj[9], pdTextAreaDh, "400", PD_LONG_SIGNED);</strong><br />
<br />
<span class="codecomment">/* Image placement */</span><br />
<strong>pdImgAdd(pd, obj[9], 0, 50, 50, 0, 0, 0, pdDrawRichTextArea, DV_NULL);</strong><br />
</tt></div>
<p><strong>INTEGRAL DSL</strong></p>
<div class="box_field"><tt><span class="codecomment">/* Lambda shortcuts */</span><br />
<br />
local o = @(label = "") CDTObj(::my.doc, label); <span class="codecomment">/* to make object */</span><br />
local p = @(id, str, len = PD_DEFAULT) CDTProp(id, str, len); <span class="codecomment">/* to add property - general */</span><br />
local s = @(id, str) CDTPropStr(id, str); <span class="codecomment">/* to add property - string */</span><br />
local i = @(id, num) CDTPropInt(id, num); <span class="codecomment">/* to add property - integer */</span><br />
local l = @(id, obj) CDTLink(id, obj); <span class="codecomment">/* to add link */</span><br />
<br />
<span class="codecomment">/* Objects */</span><br />
<br />
local obj_0 = o("Text Fragment Outline Style");<br />
local obj_1 = o("Text Fragment Body Style");<br />
local obj_2 = o("Text Fragment Shadow Style");<br />
local obj_3 = o("Text Fragment Outline");<br />
local obj_4 = o("Text Fragment Shadow");<br />
local obj_5 = o("Text Fragment Typography");<br />
local obj_6 = o("Text Fragment Layout");<br />
local obj_7 = o("Text Fragment Ruler");<br />
local obj_8 = o("Text Fragment");<br />
local obj_9 = o("RichTextArea");<br />
<br />
<span class="codecomment">/* Object Properties */</span><br />
<br />
obj_0 + s(pdRGBT, "50641400");<br />
<br />
obj_1 + s(pdRGBT, "B4961400");<br />
<br />
obj_2 + s(pdRGBT, "80808078");<br />
obj_2 + s(pdEP, "030A");<br />
<br />
obj_3 + l(pdStylePtr, obj_0);<br />
obj_3 + i(pdLineThickness, 240);<br />
<br />
obj_4 + l(pdStylePtr, obj_2);<br />
obj_4 + i(pdShadowDx, 5);<br />
obj_4 + i(pdShadowDy, 5);<br />
<br />
obj_5 + l(pdBodyPtr, obj_1);<br />
obj_5 + l(pdShadowPtr, obj_4);<br />
obj_5 + l(pdOutlinePtr, obj_3);<br />
obj_5 + i(pdFontIndex, 0);<br />
obj_5 + i(pdFontDw, 90);<br />
obj_5 + i(pdFontDh, 90);<br />
<br />
obj_6 + i(pdSpacingRow, 10);<br />
obj_6 + i(pdSpacingLetter, 5);<br />
obj_6 + i(pdKerning, 1);<br />
obj_6 + i(pdAlign, 3);<br />
<br />
obj_7 + p(pdTabStopPositions, "40, 80, 150, 220");<br />
obj_7 + p(pdTabStopFlags, "1, 0, 0, 2");<br />
<br />
obj_8 + l(pdTypographyPtr, obj_5);<br />
obj_8 + l(pdTextLayoutPtr, obj_6);<br />
obj_8 + l(pdTextRulerHorPtr, obj_7);<br />
obj_8 + s(pdTextString_08, "This is a simple text fragment");<br />
<br />
obj_9 + l(pdTextFragmentPtr, obj_8);<br />
obj_9 + i(pdTextAreaDw, 800);<br />
obj_9 + i(pdTextAreaDh, 400);<br />
<br />
<span class="codecomment">/* Image Pinning */</span><br />
<br />
obj_9.Pin(0, 50, 50, pdDrawRichTextArea);<br />
</tt></div>



&nbsp;
<br />
<br />
<a href="../../common/manual/index.htm"><img src="../../common/images/index.gif" border="0" alt="Index" /></a><br />&nbsp;
</body>
</html>
